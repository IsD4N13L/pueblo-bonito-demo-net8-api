name: üöÄ Deploy via OpenVPN to Jenkins

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      jenkins_job:
        description: 'Nombre del job de Jenkins a ejecutar'
        required: false
        default: 'default-build-job'
      environment:
        description: 'Ambiente de despliegue'
        required: false
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  # Variables de configuraci√≥n
  OPENVPN_TIMEOUT: 30
  JENKINS_TIMEOUT: 300
  MAX_RETRIES: 3

jobs:
  deploy:
    name: üîê Deploy via OpenVPN
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
    # 1. Checkout del c√≥digo
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # 2. Configurar informaci√≥n del build
    - name: üìã Set Build Info
      id: build-info
      run: |
        echo "build_number=${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
        echo "commit_sha=${GITHUB_SHA:0:8}" >> $GITHUB_OUTPUT
        echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
        echo "timestamp=$(date -u +%Y%m%d_%H%M%S)" >> $GITHUB_OUTPUT
        
        # Determinar el job de Jenkins basado en la rama
        if [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "jenkins_job=production-deploy" >> $GITHUB_OUTPUT
          echo "environment=production" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
          echo "jenkins_job=staging-deploy" >> $GITHUB_OUTPUT  
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "jenkins_job=${{ github.event.inputs.jenkins_job || 'feature-build' }}" >> $GITHUB_OUTPUT
          echo "environment=${{ github.event.inputs.environment || 'staging' }}" >> $GITHUB_OUTPUT
        fi

    # 3. Mostrar informaci√≥n del despliegue
    - name: üìä Display Deployment Info
      run: |
        echo "üîß **Informaci√≥n del Despliegue**"
        echo "================================"
        echo "üåü Branch: ${{ steps.build-info.outputs.branch }}"
        echo "üèóÔ∏è Build: #${{ steps.build-info.outputs.build_number }}"
        echo "üì¶ Commit: ${{ steps.build-info.outputs.commit_sha }}"
        echo "üéØ Environment: ${{ steps.build-info.outputs.environment }}"
        echo "‚öôÔ∏è Jenkins Job: ${{ steps.build-info.outputs.jenkins_job }}"
        echo "üïê Timestamp: ${{ steps.build-info.outputs.timestamp }}"
        echo "================================"

    # 4. Instalar OpenVPN
    - name: üîß Install OpenVPN
      run: |
        echo "üîß Instalando OpenVPN..."
        sudo apt update
        sudo apt install -y openvpn openvpn-systemd-resolved
        echo "‚úÖ OpenVPN instalado correctamente"

    # 5. Configurar cliente OpenVPN
    - name: üîê Setup OpenVPN Client
      run: |
        echo "üîê Configurando cliente OpenVPN..."
        
        # Crear directorio para configuraci√≥n
        sudo mkdir -p /etc/openvpn/client
        
        # Crear archivo de configuraci√≥n desde secret
        echo "${{ secrets.OPENVPN_CLIENT_CONF }}" | sudo tee /etc/openvpn/client/client.conf > /dev/null
        
        # Verificar que la configuraci√≥n se cre√≥ correctamente
        if [ ! -s /etc/openvpn/client/client.conf ]; then
          echo "‚ùå Error: Archivo de configuraci√≥n OpenVPN vac√≠o"
          exit 1
        fi
        
        # Mostrar informaci√≥n b√°sica (sin exponer secrets)
        echo "‚úÖ Configuraci√≥n OpenVPN creada"
        echo "üìÑ Tama√±o del archivo: $(wc -l < /etc/openvpn/client/client.conf) l√≠neas"

    # 6. Conectar a OpenVPN
    - name: üåê Connect to OpenVPN
      id: vpn-connect
      run: |
        echo "üåê Conectando a OpenVPN..."
        
        # Iniciar OpenVPN en background
        sudo openvpn --config /etc/openvpn/client/client.conf --daemon openvpn-client
        
        echo "‚è≥ Esperando conexi√≥n VPN..."
        
        # Esperar a que se establezca la conexi√≥n
        RETRY_COUNT=0
        VPN_CONNECTED=false
        
        while [ $RETRY_COUNT -lt $OPENVPN_TIMEOUT ]; do
          if ip addr show tun0 >/dev/null 2>&1; then
            VPN_IP=$(ip addr show tun0 | grep 'inet ' | awk '{print $2}' | cut -d/ -f1)
            if [ ! -z "$VPN_IP" ]; then
              echo "‚úÖ VPN conectada con IP: $VPN_IP"
              echo "vpn_ip=$VPN_IP" >> $GITHUB_OUTPUT
              VPN_CONNECTED=true
              break
            fi
          fi
          
          echo "‚è≥ Intentando conexi√≥n... ($((RETRY_COUNT + 1))/$OPENVPN_TIMEOUT)"
          sleep 1
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done
        
        if [ "$VPN_CONNECTED" = false ]; then
          echo "‚ùå Error: No se pudo establecer conexi√≥n VPN"
          echo "üìã Logs de OpenVPN:"
          sudo journalctl -u openvpn-client --no-pager -n 20 || true
          exit 1
        fi

    # 7. Verificar conectividad a Jenkins
    - name: üîç Test Jenkins Connectivity
      run: |
        echo "üîç Verificando conectividad a Jenkins..."
        
        JENKINS_URL="http://${{ secrets.JENKINS_INTERNAL_IP }}:${{ secrets.JENKINS_PORT || '8080' }}"
        
        # Ping al servidor Jenkins
        if ping -c 3 -W 3 ${{ secrets.JENKINS_INTERNAL_IP }} >/dev/null 2>&1; then
          echo "‚úÖ Ping a Jenkins exitoso"
        else
          echo "‚ö†Ô∏è Ping a Jenkins fall√≥, pero continuando..."
        fi
        
        # Verificar acceso HTTP a Jenkins
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt 5 ]; do
          if curl -s --connect-timeout 10 --max-time 20 "$JENKINS_URL/api/json" >/dev/null 2>&1; then
            echo "‚úÖ Jenkins accesible en: $JENKINS_URL"
            break
          fi
          
          echo "‚è≥ Esperando acceso a Jenkins... ($((RETRY_COUNT + 1))/5)"
          sleep 5
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done

    # 8. Ejecutar Job de Jenkins
    - name: ‚öôÔ∏è Trigger Jenkins Job
      id: jenkins-job
      run: |
        echo "‚öôÔ∏è Ejecutando job de Jenkins..."
        
        JENKINS_URL="http://${{ secrets.JENKINS_INTERNAL_IP }}:${{ secrets.JENKINS_PORT || '8080' }}"
        JOB_NAME="${{ steps.build-info.outputs.jenkins_job }}"
        JENKINS_USER="${{ secrets.JENKINS_USER }}"
        JENKINS_TOKEN="${{ secrets.JENKINS_TOKEN }}"
        JENKINS_REMOTE_TOKEN="${{ secrets.JENKINS_REMOTE_TOKEN}}"
        
        # Par√°metros del job
        BUILD_PARAMS="BUILD_NUMBER=${{ steps.build-info.outputs.build_number }}"
        BUILD_PARAMS="${BUILD_PARAMS}&COMMIT_SHA=${{ steps.build-info.outputs.commit_sha }}"
        BUILD_PARAMS="${BUILD_PARAMS}&BRANCH=${{ steps.build-info.outputs.branch }}"
        BUILD_PARAMS="${BUILD_PARAMS}&ENVIRONMENT=${{ steps.build-info.outputs.environment }}"
        BUILD_PARAMS="${BUILD_PARAMS}&GITHUB_RUN_ID=${{ github.run_id }}"
        BUILD_PARAMS="${BUILD_PARAMS}&TRIGGERED_BY=GitHub Actions"
        
        echo "üéØ Job: $JOB_NAME"
        echo "üìã Par√°metros: $BUILD_PARAMS"
        
        # Ejecutar job con par√°metros
        JENKINS_JOB_URL="${JENKINS_URL}/job/${JOB_NAME}/buildWithParameters?token=${JENKINS_REMOTE_TOKEN}"
        
        echo "üöÄ Disparando job de Jenkins..."
        HTTP_CODE=$(curl -s -w "%{http_code}" \
          --user "${JENKINS_USER}:${JENKINS_TOKEN}" \
          --data "$BUILD_PARAMS" \
          --output /tmp/jenkins_response.txt \
          "$JENKINS_JOB_URL")
        
        echo "üìä C√≥digo de respuesta HTTP: $HTTP_CODE"
        
        if [ "$HTTP_CODE" -eq 201 ] || [ "$HTTP_CODE" -eq 200 ]; then
          echo "‚úÖ Job de Jenkins disparado correctamente"
          
          # Obtener n√∫mero de build de la queue
          QUEUE_ID=$(curl -s \
            --user "${JENKINS_USER}:${JENKINS_TOKEN}" \
            "${JENKINS_URL}/job/${JOB_NAME}/api/json" | \
            jq -r '.nextBuildNumber // empty')
          
          if [ ! -z "$QUEUE_ID" ] && [ "$QUEUE_ID" != "null" ]; then
            BUILD_NUMBER=$((QUEUE_ID - 1))
            echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
            echo "üî¢ N√∫mero de build estimado: $BUILD_NUMBER"
          fi
        else
          echo "‚ùå Error al disparar job de Jenkins"
          echo "üìã Respuesta del servidor:"
          cat /tmp/jenkins_response.txt || true
          exit 1
        fi

    # 9. Monitorear progreso del job (opcional)
    - name: üìä Monitor Jenkins Job
      if: success()
      run: |
        echo "üìä Monitoreando progreso del job..."
        
        JENKINS_URL="http://${{ secrets.JENKINS_INTERNAL_IP }}:${{ secrets.JENKINS_PORT || '8080' }}"
        JOB_NAME="${{ steps.build-info.outputs.jenkins_job }}"
        JENKINS_USER="${{ secrets.JENKINS_USER }}"
        JENKINS_TOKEN="${{ secrets.JENKINS_TOKEN }}"
        
        # Esperar un poco antes de empezar a monitorear
        sleep 10
        
        MONITOR_COUNT=0
        MAX_MONITOR_TIME=30 # 5 minutos m√°ximo
        
        while [ $MONITOR_COUNT -lt $MAX_MONITOR_TIME ]; do
          # Obtener informaci√≥n del √∫ltimo build
          JOB_INFO=$(curl -s \
            --user "${JENKINS_USER}:${JENKINS_TOKEN}" \
            "${JENKINS_URL}/job/${JOB_NAME}/lastBuild/api/json" 2>/dev/null || echo '{}')
          
          BUILD_RESULT=$(echo "$JOB_INFO" | jq -r '.result // empty')
          BUILD_NUMBER=$(echo "$JOB_INFO" | jq -r '.number // empty')
          IS_BUILDING=$(echo "$JOB_INFO" | jq -r '.building // false')
          
          if [ ! -z "$BUILD_NUMBER" ] && [ "$BUILD_NUMBER" != "null" ]; then
            if [ "$IS_BUILDING" = "true" ]; then
              echo "‚è≥ Build #$BUILD_NUMBER en progreso..."
            elif [ ! -z "$BUILD_RESULT" ] && [ "$BUILD_RESULT" != "null" ]; then
              echo "üèÅ Build #$BUILD_NUMBER completado con resultado: $BUILD_RESULT"
              
              if [ "$BUILD_RESULT" = "SUCCESS" ]; then
                echo "‚úÖ Job de Jenkins completado exitosamente"
              else
                echo "‚ùå Job de Jenkins fall√≥ con resultado: $BUILD_RESULT"
              fi
              break
            fi
          fi
          
          sleep 10
          MONITOR_COUNT=$((MONITOR_COUNT + 1))
        done
        
        # URL del job para referencia
        echo "üîó URL del job: ${JENKINS_URL}/job/${JOB_NAME}/"

    # 10. Cleanup - Desconectar VPN
    - name: üßπ Cleanup OpenVPN
      if: always()
      run: |
        echo "üßπ Desconectando OpenVPN..."
        
        # Terminar proceso OpenVPN
        sudo pkill -f "openvpn.*client.conf" || true
        
        # Limpiar archivos temporales
        sudo rm -f /etc/openvpn/client/client.conf
        
        echo "‚úÖ Cleanup completado"

    # 11. Notificaci√≥n de resultado
    - name: üì¢ Deployment Summary
      if: always()
      run: |
        echo "üì¢ **RESUMEN DEL DESPLIEGUE**"
        echo "============================"
        echo "üåü Branch: ${{ steps.build-info.outputs.branch }}"
        echo "üèóÔ∏è Build: #${{ steps.build-info.outputs.build_number }}"
        echo "üéØ Environment: ${{ steps.build-info.outputs.environment }}"
        echo "‚öôÔ∏è Jenkins Job: ${{ steps.build-info.outputs.jenkins_job }}"
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Estado: EXITOSO"
        else
          echo "‚ùå Estado: FALLIDO"
        fi
        
        echo "üïê Tiempo total: ${{ job.status == 'success' && 'Completado' || 'Interrumpido' }}"
        echo "============================"
